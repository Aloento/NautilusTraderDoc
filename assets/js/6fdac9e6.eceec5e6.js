"use strict";(globalThis.webpackChunknautilus_trader=globalThis.webpackChunknautilus_trader||[]).push([[9555],{8018:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"concepts/instruments","title":"Instruments","description":"The Instrument base class represents the core specification for any tradable asset/contract. There are","source":"@site/docs/concepts/instruments.md","sourceDirName":"concepts","slug":"/concepts/instruments","permalink":"/concepts/instruments","draft":false,"unlisted":false,"editUrl":"https://github.com/Aloento/NautilusTraderDoc/tree/main/docs/concepts/instruments.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Execution","permalink":"/concepts/execution"},"next":{"title":"Live Trading","permalink":"/concepts/live"}}');var s=t(7259),r=t(9087);const a={},o="Instruments",c={},l=[{value:"Symbology",id:"symbology",level:2},{value:"Backtesting",id:"backtesting",level:2},{value:"Live trading",id:"live-trading",level:2},{value:"Finding instruments",id:"finding-instruments",level:2},{value:"Precisions and increments",id:"precisions-and-increments",level:2},{value:"Limits",id:"limits",level:2},{value:"Prices and quantities",id:"prices-and-quantities",level:2},{value:"Margins and fees",id:"margins-and-fees",level:2},{value:"When margins apply?",id:"when-margins-apply",level:3},{value:"Vocabulary",id:"vocabulary",level:3},{value:"Margin calculation formula",id:"margin-calculation-formula",level:3},{value:"Implementation details",id:"implementation-details",level:3},{value:"Commissions",id:"commissions",level:2},{value:"Built-in fee models",id:"built-in-fee-models",level:3},{value:"Creating custom fee models",id:"creating-custom-fee-models",level:3},{value:"Using fee models in practice",id:"using-fee-models-in-practice",level:3},{value:"Additional info",id:"additional-info",level:3},{value:"Synthetic instruments",id:"synthetic-instruments",level:2},{value:"Formula",id:"formula",level:3},{value:"Subscribing",id:"subscribing",level:3},{value:"Updating formulas",id:"updating-formulas",level:3},{value:"Trigger instrument IDs",id:"trigger-instrument-ids",level:3},{value:"Error handling",id:"error-handling",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"instruments",children:"Instruments"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Instrument"})," base class represents the core specification for any tradable asset/contract. There are\ncurrently a number of subclasses representing a range of ",(0,s.jsx)(n.em,{children:"asset classes"})," and ",(0,s.jsx)(n.em,{children:"instrument classes"})," which are supported by the platform:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Equity"})," (listed shares or ETFs traded on cash markets)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FuturesContract"})," (deliverable futures contract with defined underlying, expiry, and multiplier)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FuturesSpread"})," (exchange-defined multi-leg futures strategy\u2014e.g., calendar or inter-commodity\u2014quoted as one instrument)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OptionContract"})," (exchange-traded option\u2014put or call\u2014on an underlying with strike and expiry)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OptionSpread"})," (exchange-defined multi-leg options strategy\u2014e.g., vertical, calendar, straddle\u2014quoted as one instrument)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BinaryOption"})," (fixed-payout option that settles to 0 or 1 based on a binary outcome)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Cfd"})," (over-the-counter Contract for Difference that tracks an underlying and is cash-settled)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Commodity"})," (spot commodity instrument\u2014e.g., gold or oil\u2014traded in cash markets)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CurrencyPair"})," (spot FX or crypto pair in BASE/QUOTE format traded in cash markets)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CryptoOption"})," (option on a crypto underlying with crypto quote/settlement; supports inverse or quanto styles)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CryptoPerpetual"})," (perpetual futures contract\u2014aka perpetual swap\u2014on crypto with no expiry; can be inverse or quanto-settled)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CryptoFuture"})," (dated, deliverable crypto futures contract with fixed expiry, underlying crypto, and settlement currency)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IndexInstrument"})," (spot index calculated from constituents; used as a reference price and not directly tradable)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BettingInstrument"})," (a sports/gaming market selection\u2014e.g., team or runner\u2014tradable on betting venues)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"symbology",children:"Symbology"}),"\n",(0,s.jsxs)(n.p,{children:["All instruments should have a unique ",(0,s.jsx)(n.code,{children:"InstrumentId"}),", which is made up of both the native symbol, and venue ID, separated by a period.\nFor example, on the Binance Futures crypto exchange, the Ethereum Perpetual Futures Contract has the instrument ID ",(0,s.jsx)(n.code,{children:"ETHUSDT-PERP.BINANCE"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["All native symbols ",(0,s.jsx)(n.em,{children:"should"})," be unique for a venue (this is not always the case e.g. Binance share native symbols between spot and futures markets),\nand the ",(0,s.jsx)(n.code,{children:"{symbol.venue}"})," combination ",(0,s.jsx)(n.em,{children:"must"})," be unique for a Nautilus system."]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"The correct instrument must be matched to a market dataset such as ticks or order book data for logically sound operation.\nAn incorrectly specified instrument may truncate data or otherwise produce surprising results."})}),"\n",(0,s.jsx)(n.h2,{id:"backtesting",children:"Backtesting"}),"\n",(0,s.jsxs)(n.p,{children:["Generic test instruments can be instantiated through the ",(0,s.jsx)(n.code,{children:"TestInstrumentProvider"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from nautilus_trader.test_kit.providers import TestInstrumentProvider\n\naudusd = TestInstrumentProvider.default_fx_ccy("AUD/USD")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Exchange specific instruments can be discovered from live exchange data using an adapters ",(0,s.jsx)(n.code,{children:"InstrumentProvider"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from nautilus_trader.adapters.binance.spot.providers import BinanceSpotInstrumentProvider\nfrom nautilus_trader.model import InstrumentId\n\nprovider = BinanceSpotInstrumentProvider(client=binance_http_client)\nawait provider.load_all_async()\n\nbtcusdt = InstrumentId.from_str("BTCUSDT.BINANCE")\ninstrument = provider.find(btcusdt)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Or flexibly defined by the user through an ",(0,s.jsx)(n.code,{children:"Instrument"})," constructor, or one of its more specific subclasses:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from nautilus_trader.model.instruments import Instrument\n\ninstrument = Instrument(...)  # <-- provide all necessary parameters\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See the full instrument ",(0,s.jsx)(n.a,{href:"/api_reference/model/instruments",children:"API Reference"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"live-trading",children:"Live trading"}),"\n",(0,s.jsxs)(n.p,{children:["Live integration adapters have defined ",(0,s.jsx)(n.code,{children:"InstrumentProvider"})," classes which work in an automated way to cache the\nlatest instrument definitions for the exchange. Refer to a particular ",(0,s.jsx)(n.code,{children:"Instrument"}),"\nobject by passing the matching ",(0,s.jsx)(n.code,{children:"InstrumentId"})," to data and execution related methods and classes that require one."]}),"\n",(0,s.jsx)(n.h2,{id:"finding-instruments",children:"Finding instruments"}),"\n",(0,s.jsx)(n.p,{children:"Since the same actor/strategy classes can be used for both backtest and live trading, you can\nget instruments in exactly the same way through the central cache:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from nautilus_trader.model import InstrumentId\n\ninstrument_id = InstrumentId.from_str("ETHUSDT-PERP.BINANCE")\ninstrument = self.cache.instrument(instrument_id)\n'})}),"\n",(0,s.jsx)(n.p,{children:"It's also possible to subscribe to any changes to a particular instrument:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"self.subscribe_instrument(instrument_id)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or subscribe to all instrument changes for an entire venue:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from nautilus_trader.model import Venue\n\nbinance = Venue("BINANCE")\nself.subscribe_instruments(binance)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When an update to the instrument(s) is received by the ",(0,s.jsx)(n.code,{children:"DataEngine"}),", the object(s) will\nbe passed to the actors/strategies ",(0,s.jsx)(n.code,{children:"on_instrument()"})," method. A user can override this method with actions\nto take upon receiving an instrument update:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from nautilus_trader.model.instruments import Instrument\n\ndef on_instrument(self, instrument: Instrument) -> None:\n    # Take some action on an instrument update\n    pass\n"})}),"\n",(0,s.jsx)(n.h2,{id:"precisions-and-increments",children:"Precisions and increments"}),"\n",(0,s.jsxs)(n.p,{children:["The instrument objects are a convenient way to organize the specification of an\ninstrument through ",(0,s.jsx)(n.em,{children:"read-only"})," properties. Correct price and quantity precisions, as well as\nminimum price and size increments, multipliers and standard lot sizes, are available."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Most of these limits are checked by the Nautilus ",(0,s.jsx)(n.code,{children:"RiskEngine"}),", otherwise invalid\nvalues for prices and quantities ",(0,s.jsx)(n.em,{children:"can"})," result in the exchange rejecting orders."]})}),"\n",(0,s.jsx)(n.h2,{id:"limits",children:"Limits"}),"\n",(0,s.jsxs)(n.p,{children:["Certain value limits are optional for instruments and can be ",(0,s.jsx)(n.code,{children:"None"}),", these are exchange\ndependent and can include:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"max_quantity"})," (maximum quantity for a single order)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"min_quantity"})," (minimum quantity for a single order)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"max_notional"})," (maximum value of a single order)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"min_notional"})," (minimum value of a single order)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"max_price"})," (maximum valid quote or order price)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"min_price"})," (minimum valid quote or order price)."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Most of these limits are checked by the Nautilus ",(0,s.jsx)(n.code,{children:"RiskEngine"}),", otherwise exceeding\npublished limits ",(0,s.jsx)(n.em,{children:"can"})," result in the exchange rejecting orders."]})}),"\n",(0,s.jsx)(n.h2,{id:"prices-and-quantities",children:"Prices and quantities"}),"\n",(0,s.jsx)(n.p,{children:"Instrument objects also offer a convenient way to create correct prices\nand quantities based on given values."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"instrument = self.cache.instrument(instrument_id)\n\nprice = instrument.make_price(0.90500)\nquantity = instrument.make_qty(150)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"The above is the recommended method for creating valid prices and quantities,\nsuch as when passing them to the order factory to create an order."})}),"\n",(0,s.jsx)(n.h2,{id:"margins-and-fees",children:"Margins and fees"}),"\n",(0,s.jsxs)(n.p,{children:["Margin calculations are handled by the ",(0,s.jsx)(n.code,{children:"MarginAccount"})," class. This section explains how margins work and introduces key concepts you need to know."]}),"\n",(0,s.jsx)(n.h3,{id:"when-margins-apply",children:"When margins apply?"}),"\n",(0,s.jsx)(n.p,{children:"Each exchange (e.g., CME or Binance) operates with a specific account type that determines whether margin calculations are applicable.\nWhen setting up an exchange venue, you'll specify one of these account types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AccountType.MARGIN"}),": Accounts that use margin calculations, which are explained below."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AccountType.CASH"}),": Simple accounts where margin calculations do not apply."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AccountType.BETTING"}),": Accounts designed for betting, which also do not involve margin calculations."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"vocabulary",children:"Vocabulary"}),"\n",(0,s.jsx)(n.p,{children:"To understand trading on margin, let\u2019s start with some key terms:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Notional Value"}),": The total contract value in the quote currency. It represents the full market value of your position. For example, with EUR/USD futures on CME (symbol 6E)."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each contract represents 125,000 EUR (EUR is base currency, USD is quote currency)."}),"\n",(0,s.jsx)(n.li,{children:"If the current market price is 1.1000, the notional value equals 125,000 EUR \xd7 1.1000 (price of EUR/USD) = 137,500 USD."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Leverage"})," (",(0,s.jsx)(n.code,{children:"leverage"}),"): The ratio that determines how much market exposure you can control relative to your account deposit. For example, with 10\xd7 leverage, you can control 10,000 USD worth of positions with just 1,000 USD in your account."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Initial Margin"})," (",(0,s.jsx)(n.code,{children:"margin_init"}),"): The margin rate required to open a position. It represents the minimum amount of funds that must be available in your account to open new positions. This is only a pre-check \u2014 no funds are actually locked."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Maintenance Margin"})," (",(0,s.jsx)(n.code,{children:"margin_maint"}),"): The margin rate required to keep a position open. This amount is locked in your account to maintain the position. It is always lower than the initial margin. You can view the total blocked funds (sum of maintenance margins for open positions) using the following in your strategy:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"self.portfolio.balances_locked(venue)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Maker/Taker Fees"}),": The fees charged by exchanges based on your order's interaction with the market:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Maker Fee (",(0,s.jsx)(n.code,{children:"maker_fee"}),'): A fee (typically lower) charged when you "make" liquidity by placing an order that remains on the order book. For example, a limit buy order below the current price adds liquidity, and the ',(0,s.jsx)(n.em,{children:"maker"})," fee applies when it fills."]}),"\n",(0,s.jsxs)(n.li,{children:["Taker Fee (",(0,s.jsx)(n.code,{children:"taker_fee"}),'): A fee (typically higher) charged when you "take" liquidity by placing an order that executes immediately. For instance, a market buy order or a limit buy above the current price removes liquidity, and the ',(0,s.jsx)(n.em,{children:"taker"})," fee applies."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Not all exchanges or instruments implement maker/taker fees. If absent, set both ",(0,s.jsx)(n.code,{children:"maker_fee"})," and ",(0,s.jsx)(n.code,{children:"taker_fee"})," to 0 for the ",(0,s.jsx)(n.code,{children:"Instrument"})," (e.g., ",(0,s.jsx)(n.code,{children:"FuturesContract"}),", ",(0,s.jsx)(n.code,{children:"Equity"}),", ",(0,s.jsx)(n.code,{children:"CurrencyPair"}),", ",(0,s.jsx)(n.code,{children:"Commodity"}),", ",(0,s.jsx)(n.code,{children:"Cfd"}),", ",(0,s.jsx)(n.code,{children:"BinaryOption"}),", ",(0,s.jsx)(n.code,{children:"BettingInstrument"}),")."]})}),"\n",(0,s.jsx)(n.h3,{id:"margin-calculation-formula",children:"Margin calculation formula"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"MarginAccount"})," class calculates margins using the following formulas:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Initial margin calculation\nmargin_init = (notional_value / leverage * margin_init) + (notional_value / leverage * taker_fee)\n\n# Maintenance margin calculation\nmargin_maint = (notional_value / leverage * margin_maint) + (notional_value / leverage * taker_fee)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Points"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Both formulas follow the same structure but use their respective margin rates (",(0,s.jsx)(n.code,{children:"margin_init"})," and ",(0,s.jsx)(n.code,{children:"margin_maint"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Each formula consists of two parts:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primary margin calculation"}),": Based on notional value, leverage, and margin rate."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fee Adjustment"}),": Accounts for the maker/taker fee."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details",children:"Implementation details"}),"\n",(0,s.jsx)(n.p,{children:"For those interested in exploring the technical implementation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/nautechsystems/nautilus_trader/blob/develop/nautilus_trader/accounting/accounts/margin.pyx",children:"nautilus_trader/accounting/accounts/margin.pyx"})}),"\n",(0,s.jsxs)(n.li,{children:["Key methods: ",(0,s.jsx)(n.code,{children:"calculate_margin_init(self, ...)"})," and ",(0,s.jsx)(n.code,{children:"calculate_margin_maint(self, ...)"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"commissions",children:"Commissions"}),"\n",(0,s.jsx)(n.p,{children:"Trading commissions represent the fees charged by exchanges or brokers for executing trades.\nWhile maker/taker fees are common in cryptocurrency markets, traditional exchanges like CME often\nemploy other fee structures, such as per-contract commissions.\nNautilusTrader supports multiple commission models to accommodate diverse fee structures across different markets."}),"\n",(0,s.jsx)(n.h3,{id:"built-in-fee-models",children:"Built-in fee models"}),"\n",(0,s.jsx)(n.p,{children:"The framework provides two built-in fee model implementations:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MakerTakerFeeModel"}),": Implements the maker/taker fee structure common in cryptocurrency exchanges, where fees are\ncalculated as a percentage of the trade value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FixedFeeModel"}),": Applies a fixed commission per trade, regardless of the trade size."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"creating-custom-fee-models",children:"Creating custom fee models"}),"\n",(0,s.jsxs)(n.p,{children:["While the built-in fee models cover common scenarios, you might encounter situations requiring specific commission structures.\nNautilusTrader's flexible architecture allows you to implement custom fee models by inheriting from the base ",(0,s.jsx)(n.code,{children:"FeeModel"})," class."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if you're trading futures on exchanges that charge per-contract commissions (like CME), you can implement\na custom fee model. When creating custom fee models, we inherit from the ",(0,s.jsx)(n.code,{children:"FeeModel"})," base class, which is implemented\nin Cython for performance reasons. This Cython implementation is reflected in the parameter naming convention,\nwhere type information is incorporated into parameter names using underscores (like ",(0,s.jsx)(n.code,{children:"Order_order"})," or ",(0,s.jsx)(n.code,{children:"Quantity_fill_qty"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"While these parameter names might look unusual to Python developers, they're a result of Cython's type system and help\nmaintain consistency with the framework's core components. Here's how you could create a per-contract commission model:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class PerContractFeeModel(FeeModel):\n    def __init__(self, commission: Money):\n        super().__init__()\n        self.commission = commission\n\n    def get_commission(self, Order_order, Quantity_fill_qty, Price_fill_px, Instrument_instrument):\n        total_commission = Money(self.commission * Quantity_fill_qty, self.commission.currency)\n        return total_commission\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This custom implementation calculates the total commission by multiplying a ",(0,s.jsx)(n.code,{children:"fixed per-contract fee"})," by the ",(0,s.jsx)(n.code,{children:"number of contracts"})," traded. The ",(0,s.jsx)(n.code,{children:"get_commission(...)"})," method receives information about the order, fill quantity, fill price\nand instrument, allowing for flexible commission calculations based on these parameters."]}),"\n",(0,s.jsxs)(n.p,{children:["Our new class ",(0,s.jsx)(n.code,{children:"PerContractFeeModel"})," inherits class ",(0,s.jsx)(n.code,{children:"FeeModel"}),", which is implemented in Cython,\nso notice the Cython-style parameter names in the method signature:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Order_order"}),": The order object, with type prefix ",(0,s.jsx)(n.code,{children:"Order_"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Quantity_fill_qty"}),": The fill quantity, with type prefix ",(0,s.jsx)(n.code,{children:"Quantity_"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Price_fill_px"}),": The fill price, with type prefix ",(0,s.jsx)(n.code,{children:"Price_"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Instrument_instrument"}),": The instrument object, with type prefix ",(0,s.jsx)(n.code,{children:"Instrument_"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These parameter names follow NautilusTrader's Cython naming conventions, where the prefix indicates the expected type.\nWhile this might seem verbose compared to typical Python naming conventions, it ensures type safety and consistency\nwith the framework's Cython codebase."}),"\n",(0,s.jsx)(n.h3,{id:"using-fee-models-in-practice",children:"Using fee models in practice"}),"\n",(0,s.jsx)(n.p,{children:"To use any fee model in your trading system, whether built-in or custom, you specify it when setting up the venue.\nHere's an example using the custom per-contract fee model:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from nautilus_trader.model.currencies import USD\nfrom nautilus_trader.model.objects import Money, Currency\n\nengine.add_venue(\n    venue=venue,\n    oms_type=OmsType.NETTING,\n    account_type=AccountType.MARGIN,\n    base_currency=USD,\n    fee_model=PerContractFeeModel(Money(2.50, USD)),  # 2.50 USD per contract\n    starting_balances=[Money(1_000_000, USD)],  # Starting with 1,000,000 USD balance\n)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"When implementing custom fee models, ensure they accurately reflect the fee structure of your target exchange.\nEven small discrepancies in commission calculations can significantly impact strategy performance metrics during backtesting."})}),"\n",(0,s.jsx)(n.h3,{id:"additional-info",children:"Additional info"}),"\n",(0,s.jsxs)(n.p,{children:["The raw instrument definition as provided by the exchange (typically from JSON serialized data) is also\nincluded as a generic Python dictionary. This is to retain all information\nwhich is not necessarily part of the unified Nautilus API, and is available to the user\nat runtime by calling the ",(0,s.jsx)(n.code,{children:".info"})," property."]}),"\n",(0,s.jsx)(n.h2,{id:"synthetic-instruments",children:"Synthetic instruments"}),"\n",(0,s.jsx)(n.p,{children:"The platform supports creating customized synthetic instruments, which can generate synthetic quote\nand trades. These are useful for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Enabling ",(0,s.jsx)(n.code,{children:"Actor"})," and ",(0,s.jsx)(n.code,{children:"Strategy"})," components to subscribe to quote or trade feeds."]}),"\n",(0,s.jsx)(n.li,{children:"Triggering emulated orders."}),"\n",(0,s.jsx)(n.li,{children:"Constructing bars from synthetic quotes or trades."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Synthetic instruments cannot be traded directly, as they are constructs that only exist locally\nwithin the platform. They serve as analytical tools, providing useful metrics based on their component\ninstruments."}),"\n",(0,s.jsx)(n.p,{children:"In the future, we plan to support order management for synthetic instruments, enabling trading of\ntheir component instruments based on the synthetic instrument's behavior."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The venue for a synthetic instrument is always designated as ",(0,s.jsx)(n.code,{children:"'SYNTH'"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"formula",children:"Formula"}),"\n",(0,s.jsxs)(n.p,{children:['A synthetic instrument is composed of a combination of two or more component instruments (which\ncan include instruments from multiple venues), as well as a "derivation formula".\nUtilizing the dynamic expression engine powered by the ',(0,s.jsx)(n.a,{href:"https://github.com/ISibboI/evalexpr",children:"evalexpr"}),"\nRust crate, the platform can evaluate the formula to calculate the latest synthetic price tick\nfrom the incoming component instrument prices."]}),"\n",(0,s.jsxs)(n.p,{children:["See the ",(0,s.jsx)(n.code,{children:"evalexpr"})," documentation for a full description of available features, operators and precedence."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"Before defining a new synthetic instrument, ensure that all component instruments are already defined and exist in the cache."})}),"\n",(0,s.jsx)(n.h3,{id:"subscribing",children:"Subscribing"}),"\n",(0,s.jsxs)(n.p,{children:["The following example demonstrates the creation of a new synthetic instrument with an actor/strategy.\nThis synthetic instrument will represent a simple spread between Bitcoin and\nEthereum spot prices on Binance. For this example, it is assumed that spot instruments for\n",(0,s.jsx)(n.code,{children:"BTCUSDT.BINANCE"})," and ",(0,s.jsx)(n.code,{children:"ETHUSDT.BINANCE"})," are already present in the cache."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from nautilus_trader.model.instruments import SyntheticInstrument\n\nbtcusdt_binance_id = InstrumentId.from_str("BTCUSDT.BINANCE")\nethusdt_binance_id = InstrumentId.from_str("ETHUSDT.BINANCE")\n\n# Define the synthetic instrument\nsynthetic = SyntheticInstrument(\n    symbol=Symbol("BTC-ETH:BINANCE"),\n    price_precision=8,\n    components=[\n        btcusdt_binance_id,\n        ethusdt_binance_id,\n    ],\n    formula=f"{btcusdt_binance_id} - {ethusdt_binance_id}",\n    ts_event=self.clock.timestamp_ns(),\n    ts_init=self.clock.timestamp_ns(),\n)\n\n# Recommended to store the synthetic instruments ID somewhere\nself._synthetic_id = synthetic.id\n\n# Add the synthetic instrument for use by other components\nself.add_synthetic(synthetic)\n\n# Subscribe to quotes for the synthetic instrument\nself.subscribe_quote_ticks(self._synthetic_id)\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"instrument_id"})," for the synthetic instrument in the above example will be structured as ",(0,s.jsx)(n.code,{children:"{symbol}.{SYNTH}"}),", resulting in ",(0,s.jsx)(n.code,{children:"'BTC-ETH:BINANCE.SYNTH'"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"updating-formulas",children:"Updating formulas"}),"\n",(0,s.jsx)(n.p,{children:"It's also possible to update a synthetic instrument formulas at any time. The following example\nshows how to achieve this with an actor/strategy."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'# Recover the synthetic instrument from the cache (assuming `synthetic_id` was assigned)\nsynthetic = self.cache.synthetic(self._synthetic_id)\n\n# Update the formula, here is a simple example of just taking the average\nnew_formula = "(BTCUSDT.BINANCE + ETHUSDT.BINANCE) / 2"\nsynthetic.change_formula(new_formula)\n\n# Now update the synthetic instrument\nself.update_synthetic(synthetic)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"trigger-instrument-ids",children:"Trigger instrument IDs"}),"\n",(0,s.jsx)(n.p,{children:"The platform allows for emulated orders to be triggered based on synthetic instrument prices. In\nthe following example, we build upon the previous one to submit a new emulated order.\nThis order will be retained in the emulator until a trigger from synthetic quotes releases it.\nIt will then be submitted to Binance as a MARKET order:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'order = self.strategy.order_factory.limit(\n    instrument_id=ETHUSDT_BINANCE.id,\n    order_side=OrderSide.BUY,\n    quantity=Quantity.from_str("1.5"),\n    price=Price.from_str("30000.00000000"),  # <-- Synthetic instrument price\n    emulation_trigger=TriggerType.DEFAULT,\n    trigger_instrument_id=self._synthetic_id,  # <-- Synthetic instrument identifier\n)\n\nself.strategy.submit_order(order)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"error-handling",children:"Error handling"}),"\n",(0,s.jsx)(n.p,{children:"Considerable effort has been made to validate inputs, including the derivation formula for\nsynthetic instruments. Despite this, caution is advised as invalid or erroneous inputs may lead to\nundefined behavior."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["See the ",(0,s.jsx)(n.code,{children:"SyntheticInstrument"})," ",(0,s.jsx)(n.a,{href:"/api_reference/model/instruments#class-syntheticinstrument-1",children:"API reference"}),"\nfor a detailed understanding of input requirements and potential exceptions."]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},9087:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6363);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);