"use strict";(globalThis.webpackChunknautilus_trader=globalThis.webpackChunknautilus_trader||[]).push([[2702],{5051:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"developer_guide/ffi","title":"FFI Memory Contract","description":"NautilusTrader exposes several C-compatible types so that compiled Rust code can be","source":"@site/docs/developer_guide/ffi.md","sourceDirName":"developer_guide","slug":"/developer_guide/ffi","permalink":"/developer_guide/ffi","draft":false,"unlisted":false,"editUrl":"https://github.com/Aloento/NautilusTraderDoc/tree/main/docs/developer_guide/ffi.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Environment Setup","permalink":"/developer_guide/environment_setup"},"next":{"title":"Packaged Data","permalink":"/developer_guide/packaged_data"}}');var s=r(7259),o=r(9087);const d={},i="FFI Memory Contract",c={},l=[{value:"Fail-fast panics at the FFI boundary",id:"fail-fast-panics-at-the-ffi-boundary",level:2},{value:"CVec lifecycle",id:"cvec-lifecycle",level:2},{value:"Capsules created on the Python side",id:"capsules-created-on-the-python-side",level:2},{value:"Capsules created on the Rust side <em>(PyO3 bindings)</em>",id:"capsules-created-on-the-rust-side-pyo3-bindings",level:2},{value:"Why there is no generic <code>cvec_drop</code> anymore",id:"why-there-is-no-generic-cvec_drop-anymore",level:2},{value:"Box-backed <code>*_API</code> wrappers (owned Rust objects)",id:"box-backed-_api-wrappers-owned-rust-objects",level:2}];function a(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"ffi-memory-contract",children:"FFI Memory Contract"})}),"\n",(0,s.jsxs)(n.p,{children:["NautilusTrader exposes several ",(0,s.jsx)(n.strong,{children:"C-compatible"})," types so that compiled Rust code can be\nconsumed from C-extensions generated by Cython or by other native languages.  The most\nimportant of these is ",(0,s.jsx)(n.code,{children:"CVec"})," \u2013 a ",(0,s.jsx)(n.em,{children:"thin"})," wrapper around a Rust ",(0,s.jsx)(n.code,{children:"Vec<T>"})," that is passed across\nthe FFI boundary ",(0,s.jsx)(n.strong,{children:"by value"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The rules below are ",(0,s.jsx)(n.em,{children:"strict"}),"; violating them results in undefined behaviour (usually a double-free or a memory leak)."]}),"\n",(0,s.jsx)(n.h2,{id:"fail-fast-panics-at-the-ffi-boundary",children:"Fail-fast panics at the FFI boundary"}),"\n",(0,s.jsxs)(n.p,{children:["Rust panics must never unwind across ",(0,s.jsx)(n.code,{children:'extern "C"'})," functions. Unwinding into C or Python is\nundefined behaviour and can corrupt the foreign stack or leave partially-dropped resources\nbehind. To enforce the fail-fast architecture we wrap every exported symbol in\n",(0,s.jsx)(n.code,{children:"crate::ffi::abort_on_panic"}),", which executes the body and calls ",(0,s.jsx)(n.code,{children:"process::abort()"})," if a panic\noccurs. The panic message is still logged before the abort, so debugging output is preserved\nwhile avoiding undefined behaviour."]}),"\n",(0,s.jsxs)(n.p,{children:["When adding new FFI functions, call ",(0,s.jsx)(n.code,{children:"abort_on_panic(|| { \u2026 })"})," around the implementation (or\nuse a helper that does so) to maintain this guarantee."]}),"\n",(0,s.jsx)(n.h2,{id:"cvec-lifecycle",children:"CVec lifecycle"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Step"}),(0,s.jsx)(n.th,{children:"Owner"}),(0,s.jsx)(n.th,{children:"Action"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"1"})}),(0,s.jsx)(n.td,{children:"Rust"}),(0,s.jsxs)(n.td,{children:["Build a ",(0,s.jsx)(n.code,{children:"Vec<T>"})," and convert it with ",(0,s.jsx)(n.code,{children:"into()"})," \u2013 this ",(0,s.jsx)(n.em,{children:"leaks"})," the vector and transfers ownership of the raw allocation to foreign code."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"2"})}),(0,s.jsx)(n.td,{children:"Foreign (Python / Cython / C)"}),(0,s.jsxs)(n.td,{children:["Use the data while the ",(0,s.jsx)(n.code,{children:"CVec"})," value is in scope. ",(0,s.jsxs)(n.strong,{children:["Do not modify the fields ",(0,s.jsx)(n.code,{children:"ptr"}),", ",(0,s.jsx)(n.code,{children:"len"}),", ",(0,s.jsx)(n.code,{children:"cap"}),"."]})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"3"})}),(0,s.jsx)(n.td,{children:"Foreign"}),(0,s.jsxs)(n.td,{children:["Exactly once, call the ",(0,s.jsx)(n.em,{children:"type-specific"})," drop helper exported by Rust (for example ",(0,s.jsx)(n.code,{children:"vec_drop_book_levels"}),", ",(0,s.jsx)(n.code,{children:"vec_drop_book_orders"}),", ",(0,s.jsx)(n.code,{children:"vec_time_event_handlers_drop"}),"). The helper reconstructs the original ",(0,s.jsx)(n.code,{children:"Vec<T>"})," with ",(0,s.jsx)(n.code,{children:"Vec::from_raw_parts"})," and lets it drop, freeing the memory."]})]})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["If step ",(0,s.jsx)(n.strong,{children:"3"})," is forgotten the allocation is leaked for the remainder of the process; if it\nis performed ",(0,s.jsx)(n.strong,{children:"twice"})," the program will double-free and likely crash."]})}),"\n",(0,s.jsx)(n.h2,{id:"capsules-created-on-the-python-side",children:"Capsules created on the Python side"}),"\n",(0,s.jsxs)(n.p,{children:["Several Cython helpers allocate temporary C buffers with ",(0,s.jsx)(n.code,{children:"PyMem_Malloc"}),", wrap them into a\n",(0,s.jsx)(n.code,{children:"CVec"}),", and return the address inside a ",(0,s.jsx)(n.code,{children:"PyCapsule"}),". ",(0,s.jsx)(n.strong,{children:"Every such capsule is created with a\ndestructor"})," (",(0,s.jsx)(n.code,{children:"capsule_destructor"})," or ",(0,s.jsx)(n.code,{children:"capsule_destructor_deltas"}),") that frees both the buffer\nand the ",(0,s.jsx)(n.code,{children:"CVec"}),". Callers must therefore ",(0,s.jsx)(n.em,{children:"not"})," free the memory manually \u2013 doing so would double\nfree."]}),"\n",(0,s.jsxs)(n.h2,{id:"capsules-created-on-the-rust-side-pyo3-bindings",children:["Capsules created on the Rust side ",(0,s.jsx)(n.em,{children:"(PyO3 bindings)"})]}),"\n",(0,s.jsxs)(n.p,{children:["When Rust code pushes a heap-allocated value into Python it ",(0,s.jsx)(n.strong,{children:"must"})," use\n",(0,s.jsx)(n.code,{children:"PyCapsule::new_with_destructor"})," so that Python knows how to free the allocation\nonce the capsule becomes unreachable. The closure/destructor is responsible\nfor reconstructing the original ",(0,s.jsx)(n.code,{children:"Box<T>"})," or ",(0,s.jsx)(n.code,{children:"Vec<T>"})," and letting it drop."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'Python::attach(|py| {\n    // allocate the value on the heap\n    let my_data = MyStruct::new();\n\n    // move it into the capsule and register a destructor\n    let capsule = pyo3::types::PyCapsule::new_with_destructor(py, my_data, None, |_, _| {})\n        .expect("capsule creation failed");\n\n    // ... pass `capsule` back to Python ...\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Do ",(0,s.jsx)(n.strong,{children:"not"})," use ",(0,s.jsx)(n.code,{children:"PyCapsule::new(\u2026, None)"}),"; that variant registers ",(0,s.jsx)(n.em,{children:"no"})," destructor\nand will leak memory unless the recipient manually extracts and frees the\npointer (something we never rely on). The codebase has been updated to follow\nthis rule everywhere \u2013 adding new FFI modules must follow the same pattern."]}),"\n",(0,s.jsxs)(n.h2,{id:"why-there-is-no-generic-cvec_drop-anymore",children:["Why there is no generic ",(0,s.jsx)(n.code,{children:"cvec_drop"})," anymore"]}),"\n",(0,s.jsxs)(n.p,{children:["Earlier versions of the codebase shipped a generic ",(0,s.jsx)(n.code,{children:"cvec_drop"})," function that always treated the\nbuffer as ",(0,s.jsx)(n.code,{children:"Vec<u8>"}),". Using it with any other element type causes a size-mismatch during\ndeallocation and corrupts the allocator\u2019s bookkeeping. Because the helper was not referenced\nanywhere inside the project it has been removed to avoid accidental misuse."]}),"\n",(0,s.jsxs)(n.h2,{id:"box-backed-_api-wrappers-owned-rust-objects",children:["Box-backed ",(0,s.jsx)(n.code,{children:"*_API"})," wrappers (owned Rust objects)"]}),"\n",(0,s.jsxs)(n.p,{children:["When the Rust core needs to hand a ",(0,s.jsx)(n.em,{children:"complex"})," value (for example an\n",(0,s.jsx)(n.code,{children:"OrderBook"}),", ",(0,s.jsx)(n.code,{children:"SyntheticInstrument"}),", or ",(0,s.jsx)(n.code,{children:"TimeEventAccumulator"}),") to foreign\ncode it allocates the value on the heap with ",(0,s.jsx)(n.code,{children:"Box::new"})," and returns a\nsmall ",(0,s.jsx)(n.code,{children:"repr(C)"})," wrapper whose only field is that ",(0,s.jsx)(n.code,{children:"Box"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[repr(C)]\npub struct OrderBook_API(Box<OrderBook>);\n\n#[unsafe(no_mangle)]\npub extern "C" fn orderbook_new(id: InstrumentId, book_type: BookType) -> OrderBook_API {\n    OrderBook_API(Box::new(OrderBook::new(id, book_type)))\n}\n\n#[unsafe(no_mangle)]\npub extern "C" fn orderbook_drop(book: OrderBook_API) {\n    drop(book); // frees the heap allocation\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Memory-safety requirements are therefore:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Every constructor (",(0,s.jsx)(n.code,{children:"*_new"}),") ",(0,s.jsx)(n.strong,{children:"must"})," have a matching ",(0,s.jsx)(n.code,{children:"*_drop"})," exported\nnext to it."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"Python/Cython"})," binding must guarantee that ",(0,s.jsx)(n.code,{children:"*_drop"})," is invoked\nexactly once. Two approaches are accepted:"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 Wrap the pointer in a ",(0,s.jsx)(n.code,{children:"PyCapsule"})," created with\n",(0,s.jsx)(n.code,{children:"PyCapsule::new_with_destructor"}),", passing a destructor that calls\nthe drop helper."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 Call the helper explicitly in ",(0,s.jsx)(n.code,{children:"__del__"}),"/",(0,s.jsx)(n.code,{children:"__dealloc__"})," on the Python\nside.  This is the historical pattern for most v1 Cython modules:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"cdef class OrderBook:\n    cdef OrderBook_API _mem\n\n    def __cinit__(self, ...):\n        self._mem = orderbook_new(...)\n\n    def __del__(self):\n        if self._mem._0 != NULL:\n            orderbook_drop(self._mem)\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Whichever style is used, remember: ",(0,s.jsx)(n.strong,{children:"forgetting the drop call leaks the\nentire structure"}),", while calling it twice will double-free and crash."]}),"\n",(0,s.jsx)(n.p,{children:"New FFI code must follow this template before it can be merged."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},9087:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>i});var t=r(6363);const s={},o=t.createContext(s);function d(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);