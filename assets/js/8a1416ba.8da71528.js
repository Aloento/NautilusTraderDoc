"use strict";(globalThis.webpackChunknautilus_trader=globalThis.webpackChunknautilus_trader||[]).push([[7699],{5521:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"concepts/architecture","title":"Architecture","description":"Welcome to the architectural overview of NautilusTrader.","source":"@site/docs/concepts/architecture.md","sourceDirName":"concepts","slug":"/concepts/architecture","permalink":"/concepts/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/Aloento/NautilusTraderDoc/tree/main/docs/concepts/architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Adapters","permalink":"/concepts/adapters"},"next":{"title":"Backtesting","permalink":"/concepts/backtesting"}}');var t=i(7259),r=i(9087);const a={},o="Architecture",l={},c=[{value:"Design philosophy",id:"design-philosophy",level:2},{value:"Quality attributes",id:"quality-attributes",level:3},{value:"Assurance-driven engineering",id:"assurance-driven-engineering",level:3},{value:"Crash-only design",id:"crash-only-design",level:3},{value:"Data integrity and fail-fast policy",id:"data-integrity-and-fail-fast-policy",level:3},{value:"Fail-fast principles",id:"fail-fast-principles",level:4},{value:"When fail-fast applies",id:"when-fail-fast-applies",level:4},{value:"Example scenarios",id:"example-scenarios",level:4},{value:"System architecture",id:"system-architecture",level:2},{value:"Core components",id:"core-components",level:3},{value:"<code>NautilusKernel</code>",id:"nautiluskernel",level:4},{value:"<code>MessageBus</code>",id:"messagebus",level:4},{value:"<code>Cache</code>",id:"cache",level:4},{value:"<code>DataEngine</code>",id:"dataengine",level:4},{value:"<code>ExecutionEngine</code>",id:"executionengine",level:4},{value:"<code>RiskEngine</code>",id:"riskengine",level:4},{value:"Environment contexts",id:"environment-contexts",level:3},{value:"Common core",id:"common-core",level:3},{value:"Data and execution flow patterns",id:"data-and-execution-flow-patterns",level:3},{value:"Data flow pattern",id:"data-flow-pattern",level:4},{value:"Execution flow pattern",id:"execution-flow-pattern",level:4},{value:"Component state management",id:"component-state-management",level:4},{value:"Messaging",id:"messaging",level:3},{value:"Framework organization",id:"framework-organization",level:2},{value:"Core / low-Level",id:"core--low-level",level:3},{value:"Components",id:"components",level:3},{value:"System implementations",id:"system-implementations",level:3},{value:"Code structure",id:"code-structure",level:2},{value:"Dependency flow",id:"dependency-flow",level:3},{value:"Type safety",id:"type-safety",level:3},{value:"Errors and exceptions",id:"errors-and-exceptions",level:3},{value:"Processes and threads",id:"processes-and-threads",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,t.jsx)(n.p,{children:"Welcome to the architectural overview of NautilusTrader."}),"\n",(0,t.jsx)(n.p,{children:"This guide dives deep into the foundational principles, structures, and designs that underpin\nthe platform. Whether you're a developer, system architect, or just curious about the inner workings\nof NautilusTrader, this section covers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The design philosophy that drives decisions and shapes the system's evolution."}),"\n",(0,t.jsx)(n.li,{children:"The overarching system architecture providing a bird's-eye view of the entire system framework."}),"\n",(0,t.jsx)(n.li,{children:"How the framework is organized to facilitate modularity and maintainability."}),"\n",(0,t.jsx)(n.li,{children:"The code structure that ensures readability and scalability."}),"\n",(0,t.jsx)(n.li,{children:"A breakdown of component organization and interaction to understand how different parts communicate and collaborate."}),"\n",(0,t.jsx)(n.li,{children:"And finally, the implementation techniques that are crucial for performance, reliability, and robustness."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Throughout the documentation, the term ",(0,t.jsx)(n.em,{children:'"Nautilus system boundary"'}),' refers to operations within\nthe runtime of a single Nautilus node (also known as a "trader instance").']})}),"\n",(0,t.jsx)(n.h2,{id:"design-philosophy",children:"Design philosophy"}),"\n",(0,t.jsx)(n.p,{children:"The major architectural techniques and design patterns employed by NautilusTrader are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Domain-driven_design",children:"Domain driven design (DDD)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Event-driven_programming",children:"Event-driven architecture"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Messaging_pattern",children:"Messaging patterns"})," (Pub/Sub, Req/Rep, point-to-point)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)",children:"Ports and adapters"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#crash-only-design",children:"Crash-only design"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These techniques have been utilized to assist in achieving certain architectural quality attributes."}),"\n",(0,t.jsx)(n.h3,{id:"quality-attributes",children:"Quality attributes"}),"\n",(0,t.jsx)(n.p,{children:"Architectural decisions are often a trade-off between competing priorities. The\nbelow is a list of some of the most important quality attributes which are considered\nwhen making design and architectural decisions, roughly in order of 'weighting'."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reliability"}),"\n",(0,t.jsx)(n.li,{children:"Performance"}),"\n",(0,t.jsx)(n.li,{children:"Modularity"}),"\n",(0,t.jsx)(n.li,{children:"Testability"}),"\n",(0,t.jsx)(n.li,{children:"Maintainability"}),"\n",(0,t.jsx)(n.li,{children:"Deployability"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"assurance-driven-engineering",children:"Assurance-driven engineering"}),"\n",(0,t.jsx)(n.p,{children:"NautilusTrader is incrementally adopting a high-assurance mindset: critical code\npaths should carry executable invariants that verify behaviour matches the\nbusiness requirements. Practically this means we:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Identify the components whose failure has the highest blast radius (core\ndomain types, risk and execution flows) and write down their invariants in\nplain language."}),"\n",(0,t.jsx)(n.li,{children:"Codify those invariants as executable checks (unit tests, property tests,\nfuzzers, static assertions) that run in CI, keeping the feedback loop light."}),"\n",(0,t.jsxs)(n.li,{children:["Prefer zero-cost safety techniques built into Rust (ownership, ",(0,t.jsx)(n.code,{children:"Result"}),"\nsurfaces, ",(0,t.jsx)(n.code,{children:"panic = abort"}),") and add targeted formal tools only where they pay\nfor themselves."]}),"\n",(0,t.jsx)(n.li,{children:"Track \u201cassurance debt\u201d alongside feature work so new integrations extend the\nsafety net rather than bypass it."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This approach preserves the platform\u2019s delivery cadence while giving mission\ncritical flows the additional scrutiny they need."}),"\n",(0,t.jsxs)(n.p,{children:["Further reading: ",(0,t.jsx)(n.a,{href:"https://highassurance.rs/",children:"High Assurance Rust"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"crash-only-design",children:"Crash-only design"}),"\n",(0,t.jsxs)(n.p,{children:["NautilusTrader embraces ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Crash-only_software",children:"crash-only design"}),",\na philosophy where ",(0,t.jsx)(n.em,{children:'"the only way to stop the system is to crash it"'}),", and ",(0,t.jsx)(n.em,{children:'"the only way to bring it\nup is to recover from a crash"'}),". This approach simplifies state management and improves reliability\nby eliminating the complexity of graceful shutdown code paths that are rarely tested."]}),"\n",(0,t.jsx)(n.p,{children:"Key principles:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single code path"})," - Recovery from crash is the primary (and only) initialization path, ensuring it is well-tested."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No graceful shutdown"})," - The system does not attempt complex cleanup procedures that may fail or hang."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Externalized state"})," - Critical state is persisted externally (database, message bus) so crashes do not lose data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fast restart"})," - The system is designed to restart quickly after a crash, minimizing downtime."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Idempotent operations"})," - Operations are designed to be safely retried after restart."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This design complements the ",(0,t.jsx)(n.a,{href:"#data-integrity-and-fail-fast-policy",children:"fail-fast policy"}),", where\nunrecoverable errors (data corruption, invariant violations) result in immediate process termination\nrather than attempting to continue in a compromised state."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"References:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://www.usenix.org/conference/hotos-ix/crash-only-software",children:"Crash-Only Software"})," - Candea & Fox, HotOS 2003 (original research paper)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://www.usenix.org/conference/osdi-04/microreboot%E2%80%94-technique-cheap-recovery",children:"Microreboot\u2014A Technique for Cheap Recovery"})," - Candea et al., OSDI 2004"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://brooker.co.za/blog/2012/01/22/crash-only.html",children:"The properties of crash-only software"})," - Marc Brooker's blog"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://lwn.net/Articles/191059/",children:"Crash-only software: More than meets the eye"})," - LWN.net article"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"http://roc.cs.berkeley.edu/",children:"Recovery-Oriented Computing (ROC) Project"})," - UC Berkeley/Stanford research"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"data-integrity-and-fail-fast-policy",children:"Data integrity and fail-fast policy"}),"\n",(0,t.jsx)(n.p,{children:"NautilusTrader prioritizes data integrity over availability for trading operations. The system employs\na strict fail-fast policy for arithmetic operations and data handling to prevent silent data corruption\nthat could lead to incorrect trading decisions."}),"\n",(0,t.jsx)(n.h4,{id:"fail-fast-principles",children:"Fail-fast principles"}),"\n",(0,t.jsx)(n.p,{children:"The system will fail fast (panic or return an error) when encountering:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Arithmetic overflow or underflow in operations on timestamps, prices, or quantities that exceed valid ranges."}),"\n",(0,t.jsx)(n.li,{children:"Invalid data during deserialization including NaN, Infinity, or out-of-range values in market data or configuration."}),"\n",(0,t.jsx)(n.li,{children:"Type conversion failures such as negative values where only positive values are valid (timestamps, quantities)."}),"\n",(0,t.jsx)(n.li,{children:"Malformed input parsing for prices, timestamps, or precision values."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Rationale:"}),"\n",(0,t.jsx)(n.p,{children:"In trading systems, corrupt data is worse than no data. A single incorrect price, timestamp, or quantity\ncan cascade through the system, resulting in:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Incorrect position sizing or risk calculations."}),"\n",(0,t.jsx)(n.li,{children:"Orders placed at wrong prices."}),"\n",(0,t.jsx)(n.li,{children:"Backtests producing misleading results."}),"\n",(0,t.jsx)(n.li,{children:"Silent financial losses."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By crashing immediately on invalid data, NautilusTrader ensures:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No silent corruption"})," - Invalid data never propagates through the system."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Immediate feedback"})," - Issues are discovered during development and testing, not in production."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Audit trail"})," - Crash logs clearly identify the source of invalid data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deterministic behavior"})," - The same invalid input always produces the same failure."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"when-fail-fast-applies",children:"When fail-fast applies"}),"\n",(0,t.jsx)(n.p,{children:"Panics are used for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Programmer errors (logic bugs, incorrect API usage)."}),"\n",(0,t.jsx)(n.li,{children:"Data that violates fundamental invariants (negative timestamps, NaN prices)."}),"\n",(0,t.jsx)(n.li,{children:"Arithmetic that would silently produce incorrect results."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Results or Options are used for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Expected runtime failures (network errors, file I/O)."}),"\n",(0,t.jsx)(n.li,{children:"Business logic validation (order constraints, risk limits)."}),"\n",(0,t.jsx)(n.li,{children:"User input validation."}),"\n",(0,t.jsx)(n.li,{children:"Library APIs exposed to downstream crates where callers need explicit error handling without relying on panics for control flow."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-scenarios",children:"Example scenarios"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// CORRECT: Panics on overflow - prevents data corruption\nlet total_ns = timestamp1 + timestamp2; // Panics if result > u64::MAX\n\n// CORRECT: Rejects NaN during deserialization\nlet price = serde_json::from_str("NaN"); // Error: "must be finite"\n\n// CORRECT: Explicit overflow handling when needed\nlet total_ns = timestamp1.checked_add(timestamp2)?; // Returns Option<UnixNanos>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This policy is implemented throughout the core types (",(0,t.jsx)(n.code,{children:"UnixNanos"}),", ",(0,t.jsx)(n.code,{children:"Price"}),", ",(0,t.jsx)(n.code,{children:"Quantity"}),", etc.)\nand ensures that NautilusTrader maintains the highest standards of data correctness for production trading."]}),"\n",(0,t.jsxs)(n.p,{children:["In production deployments, the system is typically configured with ",(0,t.jsx)(n.code,{children:"panic = abort"})," in release builds,\nensuring that any panic results in a clean process termination that can be handled by process supervisors\nor orchestration systems. This aligns with the ",(0,t.jsx)(n.a,{href:"#crash-only-design",children:"crash-only design"})," principle, where unrecoverable errors\nlead to immediate restart rather than attempting to continue in a potentially corrupted state."]}),"\n",(0,t.jsx)(n.h2,{id:"system-architecture",children:"System architecture"}),"\n",(0,t.jsxs)(n.p,{children:["The NautilusTrader codebase is actually both a framework for composing trading\nsystems, and a set of default system implementations which can operate in various\n",(0,t.jsx)(n.a,{href:"#environment-contexts",children:"environment contexts"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://github.com/nautechsystems/nautilus_trader/blob/develop/assets/architecture-overview.png?raw=true",alt:"Architecture",title:"architecture"})}),"\n",(0,t.jsx)(n.h3,{id:"core-components",children:"Core components"}),"\n",(0,t.jsx)(n.p,{children:"The platform is built around several key components that work together to provide a comprehensive trading system:"}),"\n",(0,t.jsx)(n.h4,{id:"nautiluskernel",children:(0,t.jsx)(n.code,{children:"NautilusKernel"})}),"\n",(0,t.jsx)(n.p,{children:"The central orchestration component responsible for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Initializing and managing all system components."}),"\n",(0,t.jsx)(n.li,{children:"Configuring the messaging infrastructure."}),"\n",(0,t.jsx)(n.li,{children:"Maintaining environment-specific behaviors."}),"\n",(0,t.jsx)(n.li,{children:"Coordinating shared resources and lifecycle management."}),"\n",(0,t.jsx)(n.li,{children:"Providing a unified entry point for system operations."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"messagebus",children:(0,t.jsx)(n.code,{children:"MessageBus"})}),"\n",(0,t.jsx)(n.p,{children:"The backbone of inter-component communication, implementing:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Publish/Subscribe patterns"}),": For broadcasting events and data to multiple consumers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Request/Response communication"}),": For operations requiring acknowledgment."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Command/Event messaging"}),": For triggering actions and notifying state changes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optional state persistence"}),": Using Redis for durability and restart capabilities."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"cache",children:(0,t.jsx)(n.code,{children:"Cache"})}),"\n",(0,t.jsx)(n.p,{children:"High-performance in-memory storage system that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Stores instruments, accounts, orders, positions, and more."}),"\n",(0,t.jsx)(n.li,{children:"Provides performant fetching capabilities for trading components."}),"\n",(0,t.jsx)(n.li,{children:"Maintains consist state across the system."}),"\n",(0,t.jsx)(n.li,{children:"Supports both read and write operations with optimized access patterns."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"dataengine",children:(0,t.jsx)(n.code,{children:"DataEngine"})}),"\n",(0,t.jsx)(n.p,{children:"Processes and routes market data throughout the system:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Handles multiple data types (quotes, trades, bars, order books, custom data, and more)."}),"\n",(0,t.jsx)(n.li,{children:"Routes data to appropriate consumers based on subscriptions."}),"\n",(0,t.jsx)(n.li,{children:"Manages data flow from external sources to internal components."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"executionengine",children:(0,t.jsx)(n.code,{children:"ExecutionEngine"})}),"\n",(0,t.jsx)(n.p,{children:"Manages order lifecycle and execution:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Routes trading commands to the appropriate adapter clients."}),"\n",(0,t.jsx)(n.li,{children:"Tracks order and position states."}),"\n",(0,t.jsx)(n.li,{children:"Coordinates with risk management systems."}),"\n",(0,t.jsx)(n.li,{children:"Handles execution reports and fills from venues."}),"\n",(0,t.jsx)(n.li,{children:"Handles reconciliation of external execution state."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"riskengine",children:(0,t.jsx)(n.code,{children:"RiskEngine"})}),"\n",(0,t.jsx)(n.p,{children:"Provides comprehensive risk management:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pre-trade risk checks and validation."}),"\n",(0,t.jsx)(n.li,{children:"Position and exposure monitoring."}),"\n",(0,t.jsx)(n.li,{children:"Real-time risk calculations."}),"\n",(0,t.jsx)(n.li,{children:"Configurable risk rules and limits."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"environment-contexts",children:"Environment contexts"}),"\n",(0,t.jsx)(n.p,{children:"An environment context in NautilusTrader defines the type of data and trading venue you are working\nwith. Understanding these contexts is crucial for effective backtesting, development, and live trading."}),"\n",(0,t.jsx)(n.p,{children:"Here are the available environments you can work with:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Backtest"}),": Historical data with simulated venues."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Sandbox"}),": Real-time data with simulated venues."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Live"}),": Real-time data with live venues (paper trading or real accounts)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"common-core",children:"Common core"}),"\n",(0,t.jsxs)(n.p,{children:["The platform has been designed to share as much common code between backtest, sandbox and live trading systems as possible.\nThis is formalized in the ",(0,t.jsx)(n.code,{children:"system"})," subpackage, where you will find the ",(0,t.jsx)(n.code,{children:"NautilusKernel"})," class,\nproviding a common core system 'kernel'."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.em,{children:"ports and adapters"})," architectural style enables modular components to be integrated into the\ncore system, providing various hooks for user-defined or custom component implementations."]}),"\n",(0,t.jsx)(n.h3,{id:"data-and-execution-flow-patterns",children:"Data and execution flow patterns"}),"\n",(0,t.jsx)(n.p,{children:"Understanding how data and execution flow through the system is crucial for effective use of the platform:"}),"\n",(0,t.jsx)(n.h4,{id:"data-flow-pattern",children:"Data flow pattern"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"External Data Ingestion"}),": Market data enters via venue-specific ",(0,t.jsx)(n.code,{children:"DataClient"})," adapters where it is normalized."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Processing"}),": The ",(0,t.jsx)(n.code,{children:"DataEngine"})," handles data processing for internal components."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Caching"}),": Processed data is stored in the high-performance ",(0,t.jsx)(n.code,{children:"Cache"})," for fast access."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event Publishing"}),": Data events are published to the ",(0,t.jsx)(n.code,{children:"MessageBus"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consumer Delivery"}),": Subscribed components (Actors, Strategies) receive relevant data events."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"execution-flow-pattern",children:"Execution flow pattern"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Command Generation"}),": User strategies create trading commands."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Command Publishing"}),": Commands are sent through the ",(0,t.jsx)(n.code,{children:"MessageBus"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Risk Validation"}),": The ",(0,t.jsx)(n.code,{children:"RiskEngine"})," validates trading commands against configured risk rules."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution Routing"}),": The ",(0,t.jsx)(n.code,{children:"ExecutionEngine"})," routes commands to appropriate venues."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"External Submission"}),": The ",(0,t.jsx)(n.code,{children:"ExecutionClient"})," submits orders to external trading venues."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event Flow Back"}),": Order events (fills, cancellations) flow back through the system."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State Updates"}),": Portfolio and position states are updated based on execution events."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"component-state-management",children:"Component state management"}),"\n",(0,t.jsx)(n.p,{children:"All components follow a finite state machine pattern with well-defined states:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PRE_INITIALIZED"}),": Component is created but not yet wired up to the system."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"READY"}),": Component is configured and wired up, but not yet running."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RUNNING"}),": Component is actively processing messages and performing operations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"STOPPED"}),": Component has been gracefully stopped and is no longer processing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DEGRADED"}),": Component is running but with reduced functionality due to errors."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FAULTED"}),": Component has encountered a critical error and cannot continue."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DISPOSED"}),": Component has been cleaned up and resources have been released."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"messaging",children:"Messaging"}),"\n",(0,t.jsxs)(n.p,{children:["To facilitate modularity and loose coupling, an extremely efficient ",(0,t.jsx)(n.code,{children:"MessageBus"})," passes messages (data, commands and events) between components."]}),"\n",(0,t.jsx)(n.p,{children:"From a high level architectural view, it's important to understand that the platform has been designed to run efficiently\non a single thread, for both backtesting and live trading. Much research and testing\nresulted in arriving at this design, as it was found the overhead of context switching between threads\ndidn't actually result in improved performance."}),"\n",(0,t.jsxs)(n.p,{children:["When considering the logic of how your algo trading will work within the system boundary, you can expect each component to consume messages\nin a deterministic synchronous way (",(0,t.jsx)(n.em,{children:"similar"})," to the ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Actor_model",children:"actor model"}),")."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Of interest is the LMAX exchange architecture, which achieves award winning performance running on\na single thread. You can read about their ",(0,t.jsx)(n.em,{children:"disruptor"})," pattern based architecture in ",(0,t.jsx)(n.a,{href:"https://martinfowler.com/articles/lmax.html",children:"this interesting article"})," by Martin Fowler."]})}),"\n",(0,t.jsx)(n.h2,{id:"framework-organization",children:"Framework organization"}),"\n",(0,t.jsx)(n.p,{children:"The codebase is organized with a layering of abstraction levels, and generally\ngrouped into logical subpackages of cohesive concepts. You can navigate to the documentation\nfor each of these subpackages from the left nav menu."}),"\n",(0,t.jsx)(n.h3,{id:"core--low-level",children:"Core / low-Level"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"core"}),": Constants, functions and low-level components used throughout the framework."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"common"}),": Common parts for assembling the frameworks various components."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"network"}),": Low-level base components for networking clients."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"serialization"}),": Serialization base components and serializer implementations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"model"}),": Defines a rich trading domain model."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"components",children:"Components"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"accounting"}),": Different account types and account management machinery."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"adapters"}),": Integration adapters for the platform including brokers and exchanges."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"analysis"}),": Components relating to trading performance statistics and analysis."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"cache"}),": Provides common caching infrastructure."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data"}),": The data stack and data tooling for the platform."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"execution"}),": The execution stack for the platform."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"indicators"}),": A set of efficient indicators and analyzers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"persistence"}),": Data storage, cataloging and retrieval, mainly to support backtesting."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"portfolio"}),": Portfolio management functionality."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"risk"}),": Risk specific components and tooling."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"trading"}),": Trading domain specific components and tooling."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"system-implementations",children:"System implementations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"backtest"}),": Backtesting componentry as well as a backtest engine and node implementations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"live"}),": Live engine and client implementations as well as a node for live trading."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"system"}),": The core system kernel common between ",(0,t.jsx)(n.code,{children:"backtest"}),", ",(0,t.jsx)(n.code,{children:"sandbox"}),", ",(0,t.jsx)(n.code,{children:"live"})," ",(0,t.jsx)(n.a,{href:"#environment-contexts",children:"environment contexts"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"code-structure",children:"Code structure"}),"\n",(0,t.jsxs)(n.p,{children:["The foundation of the codebase is the ",(0,t.jsx)(n.code,{children:"crates"})," directory, containing a collection of Rust crates including a C foreign function interface (FFI) generated by ",(0,t.jsx)(n.code,{children:"cbindgen"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The bulk of the production code resides in the ",(0,t.jsx)(n.code,{children:"nautilus_trader"})," directory, which contains a collection of Python/Cython subpackages and modules."]}),"\n",(0,t.jsx)(n.p,{children:"Python bindings for the Rust core are provided by statically linking the Rust libraries to the C extension modules generated by Cython at compile time (effectively extending the CPython API)."}),"\n",(0,t.jsx)(n.h3,{id:"dependency-flow",children:"Dependency flow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         \u2502\n\u2502                         \u2502\n\u2502     nautilus_trader     \u2502\n\u2502                         \u2502\n\u2502     Python / Cython     \u2502\n\u2502                         \u2502\n\u2502                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n C API       \u2502\n             \u2502\n             \u2502\n             \u2502\n C API       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         \u2502\n\u2502                         \u2502\n\u2502      nautilus_core      \u2502\n\u2502                         \u2502\n\u2502          Rust           \u2502\n\u2502                         \u2502\n\u2502                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"Both Rust and Cython are build dependencies. The binary wheels produced from a build do not require\nRust or Cython to be installed at runtime."})}),"\n",(0,t.jsx)(n.h3,{id:"type-safety",children:"Type safety"}),"\n",(0,t.jsx)(n.p,{children:"The design of the platform prioritizes software correctness and safety at the highest level."}),"\n",(0,t.jsxs)(n.p,{children:["The Rust codebase in ",(0,t.jsx)(n.code,{children:"nautilus_core"})," is always type safe and memory safe as guaranteed by the ",(0,t.jsx)(n.code,{children:"rustc"})," compiler,\nand so is ",(0,t.jsx)(n.em,{children:"correct by construction"})," (unless explicitly marked ",(0,t.jsx)(n.code,{children:"unsafe"}),", see the Rust section of the ",(0,t.jsx)(n.a,{href:"/developer_guide/rust",children:"Developer Guide"}),")."]}),"\n",(0,t.jsx)(n.p,{children:"Cython provides type safety at the C level at both compile time, and runtime:"}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["If you pass an argument with an invalid type to a Cython implemented module with typed parameters,\nthen you will receive a ",(0,t.jsx)(n.code,{children:"TypeError"})," at runtime."]})}),"\n",(0,t.jsxs)(n.p,{children:["If a function or method's parameter is not explicitly typed to accept ",(0,t.jsx)(n.code,{children:"None"}),", passing ",(0,t.jsx)(n.code,{children:"None"})," as an\nargument will result in a ",(0,t.jsx)(n.code,{children:"ValueError"})," at runtime."]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsx)(n.p,{children:"The above exceptions are not explicitly documented to prevent excessive bloating of the docstrings."})}),"\n",(0,t.jsx)(n.h3,{id:"errors-and-exceptions",children:"Errors and exceptions"}),"\n",(0,t.jsx)(n.p,{children:"Every attempt has been made to accurately document the possible exceptions which\ncan be raised from NautilusTrader code, and the conditions which will trigger them."}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsx)(n.p,{children:"There may be other undocumented exceptions which can be raised by Python's standard\nlibrary, or from third party library dependencies."})}),"\n",(0,t.jsx)(n.h3,{id:"processes-and-threads",children:"Processes and threads"}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"For optimal performance and to prevent potential issues related to Python's memory\nmodel and equality, it is highly recommended to run each trader instance in a separate process."})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},9087:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6363);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);